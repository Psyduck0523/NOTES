[TOC]



# MOOC 翁恺 C语言程序设计入门 笔记



To C or not to C,that is a question.



## 判断与循环

### 多路分支

- 单一输入,多分支判断输出.

#### switch case

```C
switch(type){
    case 1:
        ****;
        break;
    case 2:
        ****;
        break;
    default:
        ****;
}
```

根据`type`这个变量或者表达式的值来确定分支,`case`后面的值是判定值,而`default`是所有判定值与type值不同时程序接着运行这之后的代码;

- switchcase与if else的不同:ifelse是按照顺序进行逐次判断,最后找到结果.而switchcase是一步就可以跳跃到所要分支上的.

- ==注意:这里的控制表达式(type)只能是整型.==

- **case后面的常量可以是常数,也可以是常数计算的表达式(比如case 1+2)**

- **case后面用const变量当常量是只有C99才可以使用的**

- ==注意:switchcase语句相当于在一串语句中设置了路标,从标记的语句开始执行,并不会自动跳过下一个case,也就是说,跳转到哪一个case后,程序将会顺序执行之后的所有case,除非遇到break或者switch结束==

- **一般每个case都会有break,只有需要特殊情况(比如合并某些分支)才会运用上一条特性**

  > 对于switchcase这个语句来说,我们可以把一些级联的东西用它来做,但是我们如何把分类标准转化为整数分辨,这应该是第一个问题.至于某些简单化的分组操作,我们可以以后用数组来做.

### 循环的例子

> 编程难在哪?难在想问题.难在把问题抽象为程序和数据,而语言的语法反而是简单的门槛.

#### log~2~X

​     

~~~C
#include<stdio.h>
int main() {
	int times = 0;
	int X;
	scanf_s("%d", &X);
	while (X > 1) {
		X /= 2;
		times ++;

	}
	printf("the result is %d", times);

	return 0;
}
~~~

- 这个程序只能处理简单的整数,而且要是正好的
- **计算之前先保存原始的值,后面可能有用**
- 观察程序的时候,注意循环的那些常数值,比如上面的1和0.要理解这些数是怎么来的

#### 计数循环





```C
int main(){
    int total = 100;
    while(total > 0){
        printf("%d\n",total);
        total--;
    }
    printf("shoot!");
    return 0;
}
```

- **如果循环次数非常大,我们可以先模拟运行一个次数较少的循环,做出推断**



#### 平均数



~~~C
int main() {
    float input = 0;
    float total = 0;
    int numbers = 0;
    scanf_s("%f", &input);
    while (input != -1) {
        total += input;
        scanf_s("%f", &input);
        numbers++;
    }
    printf("the result is %f\n", total / numbers);
    return 0;
}

~~~

- 一个平均数的算法,我们不需要把每一个输入全部存进去,我们需要的仅仅是一个和,还有数据的个数.
- 设计程序的时候要搞清楚什么是必须的什么是冗余的.
- 设计思维非常重要.



#### 猜数



> 循环程序的重点是循环的条件,无论是循环进入的条件还是终止的条件
>
> > 这里关键是,我们如何获得一个随机数?我们需要一个函数,`rand()`

```C
#include<stdio.h>
#include<stdlib.h>
#include<time.h>

int main(){

    srand(time(0));  
    int a = rand();		//这个数非常大
    
    int num = a%100 + 1;
    int count = 0;
    int b;
    
 	do{
        printf("请猜出这个100以内的正整数\n");
        scanf_S("%d",&b);
        count++;
        if(num>b){
            printf("小了\n");
        }else if(num<b){
            printf("大了\n");
        }
    }while(num != b);
    printf("你猜对啦!!!你只用了%d次就猜中了答案!",count);
    return 0;
    
}
```



#### 整数求逆



```C
int main(){
    int x;
    scanf_s("%d",&x);//输入一个整数
    int digit;
    while(x>0){
        digit = x%10;
        x/=10;
      printf("%d",digit);
    }

   return 0;
}
```

> 上面的代码没有考虑0作为首位的情况

```C
int main(){
    int x;
    scanf_s("%d",&x);
    int digit;
    int ret;
    while(x>0){
        digit = x%10;
        ret = ret*10 + digit;
        x/=10;
    }
    printf("%d",ret);
    return 0;
}
```

> 这个代码考虑到了首位为0的情况





## 循环控制

 

### 循环控制基础



#### 素数判断

```C
    int x;
    int prime = 1;
    scanf_s("%d", &x);
    for ( int i = 2; i < x; i++) {
        if (x % i == 0) {
            prime = 0;
            printf("%d\n", i);
         
        }
    }
    if (prime == 1) {
        printf("是素数\n");
    }
    else {
        printf("不是素数,其因数列表已经列在上面\n");
    }


```

> 如果我们仅仅想要判断是否为素数,我们就不必打印其因数,同时也不必一直循环直到i= x-1,那么有什么方法让我们一旦判定此数为素数就离开循环呢?

- 引入`break`

  break我们在switchcase里面已经见过一次了,那时候它的作用是使原本顺序执行的语句在遇到它之后跳出switchcase,这里的break也是一样,它的作用是使得程序在碰到它之后跳出循环.	于是我们的程序就可以修改如下:

```C
    int x;
    int prime = 1;
    scanf_s("%d", &x);
    for ( int i = 2; i < x; i++) {
        if (x % i == 0) {
            prime = 0;
            break; 
        }
    }
    if (prime == 1) {
        printf("是素数\n");
    }
    else {
        printf("不是素数\n");
    }

```

- 引入`continue`

  continue指的是跳过此轮循环剩下的语句,但是不离开循环而是进入下一轮循环.

  ```C
      int x;
      int prime = 1;
      scanf_s("%d", &x);
      for ( int i = 2; i < x; i++) {
          if (x % i == 0) {
              prime = 0;
              continue; 
          }
          printf("%d",i);
      }
      if (prime == 1) {
          printf("是素数\n");
      }
      else {
          printf("不是素数\n");
      }
  ```

  

  > 上面的代码就可以利用continue让遇到非因数的时候打印非因数,如果用break的话我们在遇到第一个因数时就跳出循环了,无法打印完全所有非因数,但是使用了continue之后我们就可以打印完全,`continue`和`break`已经揭示了==循环控制==的意思-------我们需要更高级的循环.



### 多重循环



#### 嵌套循环:循环之中还是循环

> 在这里我们又接触到了更高级的循环,在整个mooc程序初级中,我们关注的重点就是各种各样的循环和判断,附带一点点的高级知识.

##### 输出指定值以内的素数

```C
int max;
int num = 0;
scanf_s("%d",&max);
for(int i = 2;i <= max;i++){
    int prime = 1;
    for(int j = 2;j < i;j++){
        if(i%j == 0){
            prime = 0;
            break;
        }
    }
    if(prime == 1){
        printf("%d\n",i);
        num++;
    }
}
printf("在%d以内的数里共有%d个素数,素数率为%f\n",max,num,(1.0*num)/max);

```

- ==注意:循环的变量要不同,这是嵌套循环的重中之重==



#### 从嵌套循环中跳出:break只能跳出其所在的循环

> 我们继续循环的学习路程.

##### 凑硬币

> 如何用1角和2角和5角的硬币凑出10元以下的金额?

当然,我们可以使用以下代码:

```C
float money;
scanf_s("%f", &money);
int i = money * 10;
int num5 = i / 5;
int num2 = (i % 5) / 2;
int num1 = (i % 5) % 2;
	
printf("凑出这个金额需要%d个五角,%d个两角,%d个一角\n", num5, num2, num1);

```

但是这样的代码没有用到循环,所以我们为了学习,要从循环的角度考虑问题.我们可以将问题改变为:求出用三种基本金额凑出输入金额的所有可能(每种基础金额至少使用一个).我们直接放上代码.

```C
float x;
int one,two,five;
scanf_s("%f",&x);
for(one = 1;one<x*10;one++){
    for(two = 1;two<x*10/2;two++){
        for(five = 1;five<x*10/5;five++){
            if(one + two*2 + five*5 == x*10){
                printf("%d个1角,%d个2角,%d个5角\n",one,two,five);
            }
        }
    }
}
```

> 这里我们如果在最里面加入break,意图只得到一组结果,但是实际上我们还是会收获很多行结果,为什么?

- `break`的性质:==只能跳过它所在的那一个循环,跳不出全部循环==

> 那我们如果就是想全部跳出怎么办?显然我们不可以每个循环都加上break,这样会导致程序早亡,那我们该怎么办呢?

- 引入接力`break`

  一个合理的想法是使用变量来控制每一个break是否工作,我们在最里层的break同步赋值一个变量为真,在其他层的break中间就可以用if判断是否执行这个break

> 但是这种手法显然过于麻烦,还有其他办法吗?

- 引入`goto`语句

  `goto`语句是一个"传送门",可以让程序跳转至你设置的地方.

```C
float x;
int one,two,five;
scanf_s("%f",&x);
for(one = 1;one<x*10;one++){
    for(two = 1;two<x*10/2;two++){
        for(five = 1;five<x*10/5;five++){
            if(one + two*2 + five*5 == x*10){
                printf("%d个1角,%d个2角,%d个5角\n",one,two,five);
                goto out;
            }
        }
    }
}
out:

```

> 需要设置标号,这样程序执行goto语句的时候就会跳转到标号之后,这个标号是自己设置的.
>
> goto语句在某些场合中非常有用,但是它也会破坏程序的结构性,所以goto语句的名声并不好,我们尽量少使用goto语句,只在某些特定场合运用即可.



### 循环应用

#### 前n项求和

##### 无判断语句

>​	求1+1/2+1/3+...+1/n的和

~~~C
int n;
double result = 0;
scanf_s("%d", &n);
for (int i = 1; i <= n; i++) {
	result += (1.0 / i);
}
printf("%f", result);


~~~

##### 有判断语句

> 求1-1/2+1/3-1/4+...+1/n

~~~C
    int n;
    double sum = 0;
    scanf_s("%d", &n);
    for (int i = 1; i <= n; i++) {
        if (i % 2 == 0) {
            sum -= (1.0 / i);
        }
        else {
            sum += (1.0/i);
        }
    }
    printf("%f", sum);

~~~



#### 求最大公约数

##### 枚举递增法

~~~c
    int a, b;
    int min;
    scanf_s("%d %d", &a, &b);
    if (a < b) {
        min = a;
    }
    else {
        min = b;
    }
    int ret;
    int i;
    for (i = 1; i <= min; i++) {
        if (a % i == 0) {
            if (b % i == 0) {
                ret = i;
            }
        }
    }
    printf("%d", ret);
~~~

##### 辗转相除法

```C
int a,b;
int x = 0;
scanf_s("%d %d",&a,&b);

while(a%b != 0){
    x = b;
    b = (a%b);
    a = x;
    
}
printf("%d",b);
```

#### 整数分解

##### 正序分解整数

> 输入一个非负整数,正序输出它的每一位

~~~C
	int a;
	scanf_s("%d", &a);
	int t = 0;
	int digit;
	while (a > 0) {
		digit = a % 10;
		t = t * 10 + digit;
		a /= 10;
	}//t现在是a的逆序数字
	while(t>0){
        printf("%d ",t%10);
        t/=10;
    }
~~~

## 数组与函数

### 数组

#### 初试数组

> 平均数计算程序再试
>
> 题目改为:计算平均数并输出所有大于平均数的数字

```C
int x;
double sum = 0;
int cnt = 0;
int num[100];
scanf_s("%d", &x);
while(x != -1) {
    num[cnt] = x;
    sum += x;
    cnt++;
    scanf_s("%d", &x);
}
if (cnt > 0) {
    printf("%f\n", sum/ cnt);
}
for(int i = 0;i<cnt;i++){
    if(num[i]>(sum/cnt)){
        printf("%d\n",num[i]);
    }
}

```



> 定义数组的形式与定义变量一样,数组中的元素可以进行赋值.
>
> 而上面程序中的检测数组中每个数大于平均值的过程我们叫`遍历数组`

#### 定义数组

- 数组是容器
- 数组是有类型的,数组一旦创建,很少改变其大小(C99之前)
- 数组中元素是在内存中连续依次排列的
- 数组下标从0开始计数
- ==注意:编译器和ide都不会检查数组下标是否超界,一旦超界,程序就会瘫痪!!==

#### 数组 散列计算

~~~c
 int x;
	int count[10];
	int i;
	for (i = 0; i < 10; i++) {
		count[i] = 0; 
	}
	scanf_s("%d", &x);
	while (x != -1) {
		if (x >= 0 && x <= 9) {
			count[x]++;
		}
		scanf_s("%d", &x);
	}
	for (i = 0; i < 10; i++) {
		printf("%d:%d\n", i, count[i]);
	}
~~~

- 这是一个经典的使用数组的程序，我们先是确定了数组的大小，接着我们定义数组，然后我们初始化数组。

- 初始化数组比较麻烦，要写循环去遍历数组。

- 然后数组就可以参与运算了。

- 最后还要遍历数组输出。

  > 得到的经验就是:遍历必定跟随着循环.

### 函数

#### 初试函数

```c
/*** 初见函数 未使用函数时的素数筛查
	int m, n;
	int sum = 0;
	int num = 0;
	
	
	scanf_s("%d%d", &m, &n);
	if (m == 1)m = 2;
	for (int i = m; i < n + 1; i++) {
		int test = 0;
		for (int j = 2; j < i; j++) {
			if ( i%j == 0) {
				test = 1;
				break;
			}
		}
		if(test == 0){
			printf("素数:%d\n", i);
			sum += i;
			num++;
		}
	}
	printf("素数的和是:%d\n", sum);
	printf("在%d到%d之间的素数共有%d个,素数率为%lf\n", m, n,num,(1.0*num)/(n-m+1));
	***/

```

我们发现,上面程序的检验素数的过程功能很单一,如果有一个程序里面需要多次检验素数,那么这样就会变得很臃肿,所以我们将这个操作打包成函数.

```c
int test(int i)
{
	int ret = 1;
	for (int j = 2; j < i; j++) {
		if (i % j == 0) {
			ret = 0;
			break;
		}
	}
	return ret;
}
int main(){
    
    int m, n;
	int sum = 0;
	int num = 0;


	scanf_s("%d%d", &m, &n);
	if (m == 1)m = 2;
	for (int i = m; i < n + 1; i++) {
		
		if (test(i)) {
			printf("素数:%d\n", i);
			sum += i;
			num++;
		}
	}
	printf("素数的和是:%d\n", sum);
	printf("在%d到%d之间的素数共有%d个,素数率为%lf\n", m, n, num, (1.0 * num) / (n - m + 1));
	
    return 0;
}
```

这样的代码会更简洁,当然这个例子不是很明显,但是当一段程序中含有三个以上的重复代码时,函数的作用就体现出来了.

- 代码复制是程序复制不良的表现.

#### 函数定义与使用

- 什么是函数?

> 函数是一块代码,接受0个或者多个参数,做一件事情,返回0个或者1个值.
>
> 可以想象成数学中的 y = f(x)

- 函数定义

>函数头: 比如` void sum (int begin ,int end)`
>
>这里的`sum` 叫做函数名,`void`叫做返回类型(void就是没有类型)
>
>函数名圆括号里面叫做参数表;
>
>函数体:就是函数的内容.

- 调用函数

  > 格式:函数名(参数值)
  >
  > ()是不能省略的,哪怕这个函数没有参数,()是计算机识别函数的一个标志
  >
  > 如果有参数,就要给出正确的数量和顺序



#### 从函数中返回

- 有的函数有返回值

  > return 停止函数的运行,并送回一个值(如果有值的话)
  >
  > 一种写法是return,另一种是return 表达式

- 函数的返回值

> 可以赋值给变量,可以再传递给参数.
>
> 甚至可以丢掉.

- 没有返回值的函数

> void 函数名( 参数表)
>
> 不能使用带值的return
>
> 可以没有return
>
> 调用的时候不能做返回值的赋值  





### 函数的参数和变量

#### 函数原型

- 函数先后关系：把函数写在main的上方，原因是C的编译器自上而下地分析代码

  > 而如果我们仅仅保留函数的返回类型,名称和参量表,并加一个分号,如` void sum(int begin,int end);`,并在main结束之后写出函数主体,编译器仍然可以识别出并通过.我们把第一行称作` 函数原型` ;main之后的函数主体叫做`函数定义`;

- 旧标准习惯把函数原型写在调用它的函数里面,现在一般写在调用它的函数前面

- 函数声明里面是可以不写参数名称的,因为编译器仅仅需要知道函数的参数类型而不需要清楚姓名,而在后面的函数定义里,由于主体部分需要用到参量名称,所以函数定义里的参量名称必须要有.

- 但我们一般都会写出来参量名称.

#### 参数传递(只传值!!!)

- 调用函数的时候,类型一定要匹配;

- 如果类型不匹配,就可能出现自动类型转换的情况,有可能原本是精度2位的小数,现在被换到int就丢失了小数部分,这样会直接干掉程序.有的ide会报错,而有的编译器就不会,所以一定要使得类型匹配.

- C语言在传统上最大的漏洞就是调用函数时给的值和参数的类型不匹配.

- 而CPP和JAVA就不会出现这种情况,在这方面很严格.

  ```C
  void swap(int a, int b);
      
      int main(){
      int a = 5;
      int b = 6;
      swap(a,b)
          printf("a = %d,b = %d",a,b);
      return 0;
  }
  void swap(int a, int b)
  {
      int t = 0;
      a = b;
      b = t;
  }
  ```

  - 上面的代码真的能交换a和b的值吗?答案是 **不能**

    > 为什么?
    >
    > 我们要明白一点 **C语言在调用函数时,永远只能传值给函数**
    >
    > 上面的程序,main函数里面的a,b将5,6两个值传给了swap函数,swap函数进行了一番操作,但是main里的a,b和swap里的a,b并无关系,仅仅是数值相同罢了.swap里的叫参数a,b,而main里的叫变量a,b.

  - *** 每个函数都有自己的变量空间,参数也位于这个独立的空间中,和其他函数没有关系***

    

#### 本地变量

- 函数每一次运行,就会产生一个独立的变量空间,在这个空间中的变量,是函数这次运行独有的,称作本地变量.也就是说,定义在函数内部的变量就是本地变量,当然包括参数也是本地变量.(也就是局部变量/自动变量)
- **变量的生成期和作用域** :生存周期,这个变量什么时候出现,又什么时候消失.作用域:在什么代码范围内可以访问这个变量.而对于` 本地变量 `,这两个答案是统一的:在大括号内部(块)

> 所以这里就可解释,[为什么函数只能传值](#参数传递(只传值!!!))!(按住ctrl点击链接)
>
> 变量的块遵循就近原则.
>
> 块之外定义的变量(全局变量)在块内仍然有效
>
> 块内变量和全局变量重名则会掩盖全局变量,保留块内变量
>
> 不能在同一个块内定义同名的变量
>
> 本地变量不会被默认初始化
>
> 参数在进入函数的时候必须要被初始化

#### 其他

如果函数原型的时候没有给参数表,在调用函数的时候编译器就会猜测类型,如果后面函数定义的时候类型和编译器猜测的不同,那么结果就会非常离谱.

- 调用函数的时候参量表里面的逗号是标点符号,而不是逗号运算符
- C语言不允许函数嵌套,也就是不能在函数里面再去定义函数,我们可以在一个函数里放一个函数的声明,但是不能在一个函数里放另一个函数的定义(也就是主体)
- `int i,j,sum(int a, int b);`这是可以的,但是不建议
- 关于main:int main 也是一个函数,

### 二维数组

[回顾一维数组知识](#数组)

#### 二维数组初识

`int a[3][5]`就是定义了一个二维数组,我们可以理解威a是一个3行5列的矩阵,第一个[ ]是行数,第二个[ ] 是列数.

- 二维数组最重要的事情就是对它做遍历!
- 二维数组遍历由于有两个参数(行和列),所以我们需要一个嵌套for循环来遍历.

~~~C
int a[3][5];
for(i = 0;i<3;i++){
    for(j = 0;j<5;j++){
        a[i][j] = i*j;
    }
}
~~~

> 上述代码就是一个例子,我们遍历这个三行五列的矩阵数组,然后把每一个元素的值赋为行数与列数的乘积(注意这里的数从0开始)

- 一定要注意:a[i][j]和a[i,j]不一样!,前者表示的是a这个二维数组里面i行j列的元素,而后者,表示a这个一维数组中(i,j)这个逗号表达式结果位置的元素
- **二维数组初始化**:列数必须给出,行数编译器可以自己数

​		每行一个{},逗号分隔

​		最后的逗号可以存在,这是古老的传统

​		如果省略,表示补0

```C
int a[][5] = {
    {0,1,2,3,4},
    {2,3,4,5,6},
};
```

> 这就是例子.

- 下面来一个井字棋胜利判定

```C
//读入矩阵
const int size = 3;
int board[size][size];
int i,j;
int num0fx;
int num0f0;
int result = -1; // -1:平局,1:X胜利,0:O胜利;
for(i = 0;i<size;i++){
    for(j = 0;j<size;j++){
        scanf("%d",&board[i][j]);
    }
}
//检查行
for(i = 0;i<size && result == -1;i++){
    num0f0 = num0fx = 0;
    for(j = 0;j<size;j++){
        if(board[i][j] == 1){
            num0f0 ++;
        }else{
            num0f0 ++;
        }
    }
    if(num0f0 == size){
        result = 0;
    }else if(num0fx == size){
        result = 1;
    }
}
//检查列(同理)
//检查正对角线
num0f0 = num0fx = 0;
for(i = 0;i<size;i++){
    if(board[i][i] == 1){
        num0fx ++;
    }else{
        num0f0 ++;
    }
}
if(num0f0 == size){
    result = 0;
}else if (num0fx == size){
    result = 1;
}
//检查反对角线同理
```





## 数组运算

### 数组运算

#### 数组运算基础

- 在一组给定的数据,判断某个数据是否存在.

```c
#include <stdio.h>
int search(int key, int a[], int length);

int main()
{
    int a[] = {2, 1, 4, 56, 7, 89, 9};
    int x;
    int loc;
    scanf_s("%d", &x);
    loc = search(x, a, sizeof(a) / sizeof(a[0]));
    if (loc != -1)
    {
        printf("%d\n", loc);
    }
    else
    {
        printf("no");
    }
    return 0;
}

int search(int key, int a[], int length)
{
    int ret = -1;
    for (int i = 0; i < length; i++)
    {
        if (a[i] == key)
        {
            ret = i;
            break;
        }
    }
    return ret;
}

```



- `int a[] = {2, 1, 4, 56, 7, 89, 9};`这是数组的集成初始化.集成初始化的时候可以不给出具体的数组的大小
- 如果初始化数组给了数组大小,然后集成初始化,没有被初始化的位置自动补0;这就衍生出了下面这种做法

`int a[ ] = {0};`这就可以把整个数组全部初始化为0;

- C99还支持一种更精细的数组赋值,如`int a[ ] = {[0] = 2, [2] = 3,6,}`

> 用[n]在初始化数据中给出定位,没有定位的数据接在前面的位置后面,上面的6就存在了a[3];
>
> 特别适合初始数据稀疏的数组.

- 上面的程序还涉及到了如何在书写代码的时候表示数组的大小,我们用sizeof来实现;
- 那么现在就有一个神奇的想法,我们能不能把一个数组赋给另一个数组呢?答案是**否定的**;
- 要想把一个数组的元素交给另一个数组,你就必须做遍历

> ```c
> for(i = 0;i<length;i++){
> b[i] = a[i];
> }
> ```

- 当数组作为函数参数的时候,我们往往要用另一个参数去传入数组的大小.

> 数组作函数参数的时候,我们不能在[ ]中给出数组的大小,也不能再利用sizeof来计算数组的元素个数(指针会讲)

#### 数组运算实例

- 判断素数的函数,我们可不可以用数组做?

>最开始我们的算法是从2到x-1逐个测试,这个循环要走n-1遍,时间复杂度就是O(n);
>
>那现在我们思考,首先偶数不是素数.我们先判断是否被2整除.所以我们可以判断2,然后从3开始每次加2.
>
>那我们再想一想,我们没必要走到x-1,我们只要走到x的平方根就好了,因为质因数分解,两竖行是对称的.(sqrt(x)是x的平方根)
>
>那么我们的sqrt函数在哪里呢?(在头文件<matn.h>里)

- 我们有没有更好的做法?

> 我们可以判断这个数是否能被已知的小于x的素数整除.
>
> 那么我们就需要一张表来获知已有的素数.那这个需求就特别适合一种自动生长的程序.

### 搜索

#### 线性搜索

- 线性搜索:有了数据,然后去遍历每一个数据,看看与输入是否匹配.这样的程序很简单.
- 要注意,在编写search函数的时候,要遵循单一出口原则.
- 还有一点:写search函数的时候要注意不要让一个变量(比如遍历的 i )承担多个功能,一专多能是不好的代码

#### 搜索实例

涉及哈希表和结构体,暂时不做笔记.

#### 二分搜索

- 二分搜索的前提是数据排序.

```c
#include <stdio.h>
int max(int a[], int len)
{
    int maxid = 0;
    for (int i = 0; i < len; i++)
    {
        if (a[i] > a[maxid])
        {
            maxid = i;
        }
    }
    return maxid;
}

int main()
{

    int a[] = {3, 5, 6, 8, 4, 7, 0, 1, 9, 10, 114514, 1919810};
    int len = sizeof(a) / sizeof(a[0]);

    // swap
    for (int i = len - 1; i > 0; i--)
    {
        int maxid = max(a, i + 1);
        int t = a[maxid];
        a[maxid] = a[i];
        a[i] = t;
    }

    for (int i = 0; i < len; i++)
    {
        printf("%d  \n", a[i]);
    }
    return 0;
}
```



### 排序初步

#### 选择排序

代码如上 

## 指针与字符串

*** 指针是C语言的灵魂***

### 指针

#### 取地址运算

- &是一个运算符,其作用是取得一个变量的地址,它的操作数必须是变量.
- 地址的大小是否与int的大小相同取决于编译器是64位还是32位.
- ==&不能取没有地址的东西==
- 用&取相邻变量的地址,会发现他们地址差一个int的大小,这说明在内存中,两个变量是紧挨着的,而且会发现先定义的变量上面,这说明在堆栈里,变量是自顶向下排的.
- 而关于数组的地址,如下

```c 
int a[10];
printf("%p\n",&a);
printf("%p\n",a);
printf("%p\n",&a[0]);
printf("%p\n",&a[1]);
```

> 000000A359FFF850
> 000000A359FFF850
> 000000A359FFF850
> 000000A359FFF854

输出如上,我们对数组地址的性质就有了了解.

#### 指针初窥

> 什么是scanf?我们知道,scanf可以把输入存到一个变量里,但为什么它要用&,上节课我们学到了,&实际上是取地址,那么我们可以猜测出,scanf一定有一个办法,可以接受到地址,然后使用它.

- ==所以是什么类型,能够存储地址呢==

  答案是:     ==指针==

  我们看看下列代码.

  ```c
  int  i;
  int* p = &i;
  int* p,q;
  int *p,q;
  ```

> 对于上面四行代码的解释,第一行,熟悉,我们定义了一个变量,变量的类型是int;
>
> 第二行,我们取出了i的地址,并把它赋值给了一个同时定义的东西,那这个同时定义的东西要储存地址,它就是指针,但是至于指针是什么类型?C语言中没有这种说法,第二行的int也只是表明这个指针指向的变量是int,而不是指针本身是int;
>
> 第三行,这行代码的意思是,令*p指向q,q是这一行定义的一个int变量,而这个 *p是一个指向int类型变量的指针.

- 作为参数的指针.

```c
void function(int *p);
int i = 0;
function(&i);
```

> 上面的代码我们看到,定义了一个不返回数值的函数,这个函数的参数表需要一个指向int类型的指针,这时候我们在调用的时候要交给函数这个int类型变量的地址,而不是直接给变量.

这样的话,我们的函数里面就得到了变量的地址,或许可以通过指针的方式实现之前函数一章中解决不了的"仅传值"问题,实现函数对变量的操作?

当函数内部拥有外界变量的地址时,函数就有了访问外界变量的能力,那么,如何访问呢?

- ==访问地址上的变量*==

> - 既可以做右值,也可以做左值.
> -   *p这个整体，我们可以看成是它所指向的那个变量.

> 如果我们在函数里,写出了 *p = x; 这一行代码,我们会惊奇地发现,这时候在函数外界的那个变量,它的值,被修改了.

- 传入地址

> 如果我写出这样的代码, int i; scanf("%d",i); 程序为什么没有报错

#### 指针与数组

- 传入函数的数组,变成了什么?

> 如果我们在函数的参数表里传一个数组,然后在函数里头计算数组的长度,在main里头也计算数组的长度,我们会发现,main中得到的是真实值,而函数里得到的,刚好是一个指针的大小;而同样的,如果我们在函数内部,将数组中的某个元素赋值了,在main里头,我们再输出它,我们会发现,即使没有*,数组元素的值,也被改变了,这说明了什么?
>
> ==传入函数的数组,就是指针==
>
> 我们做一个实验,我们把void f(int a[],int len)改为void f(int *a;int len),同时main里面的调用也做同样改变,我们会发现,程序编译,没有任何问题.
>
> 没有任何问题.
>
> 所以我们初窥蹊径:
>
> **数组和指针好像有什么联系**

- 数组变量是特殊的指针

> - 数组变量本身表达地址.所以 int a[10]; int *p = a; 这样写没有任何问题.
> - 但是数组的单元表达的是变量,所以 int a[10]; int *p = &a[0]; 才是正确的.
> - a == &a[0]; a的地址,就等于a[0] 的地址.
>
> - [ ]可以对数组用,也可以对指针用.
>
> > ```c
> > int a = 2;
> > int *p = &a;
> > printf("*p = %d\n",*p);
> > printf("p[0] = %d\n",p[0]);
> > ```
> >
> > 我们会发现,*p = 2; p[0] = 2; 这是为什么? 当我们写出p[0]的时候,编译器认为p应该是一个数组,所以它就打印出了"数组"p的第一个单元. p[0]指的是把p指向的地方,当作一个数组.
>
> - *运算符也可以对数组做.
>
> > 例如  printf("%d",*a);输出的是a数组的第一个元素.

> 所以我们可以有一些总结,*运算符,比如 *p , *a, 本质上都是去找 *后的东西所储存的地址,然后调用那个地址所对应的数值; [ ]运算符,则是找[ ]前面东西所储存的地址,然后根据[ ]里的数字来一个个往后查找,然后调用.所以如果我们说p[2],那就错啦,因为p中只存着一个地址,这个地址后面跟着的不是我们设定好的东西(很可能是奇怪的数字);
>
> - 数组变量可以看作是const的指针,所以不能被赋值
>
> 所以我们不能说 b = a;(a,b都是数组);

### 字符类型

#### 字符类型基础

- char 是一种整数,也是一种特殊的类型,字符.

> - 用单引号表示的字符字面量: 'a','2';
> - 字符的转换说明是%c;
> - ''也是一个字符;
>
> > 我们做个实验
> >
> > ```c
> > char c;
> > char d;
> > c = 1;
> > d = '1';
> > if(c == d)
> > {
> >  printf("ok");
> > }else{
> >  printf("wrong");
> >     return 0;
> > }
> > ```
> >
> > 我们发现结果是wrong,这说明了'1'和1是不同的,而如果我们把c和d都以整数类型输出,我们发现,c是1,而d是49.
> >
> > 这个时候,我们就遇到了ASCII.

- 字符的输入输出

> ```c
> char c;
> int i;
> scanf("%c",&c);
> scanf("&d",&i);
> c = i;
> ```
>
> 如果我们输入1,第二行会把1这个字符存入c中,我们要是想让c还是1,我们就要再输入49,因为下面代码把整数49存入c,又因为c是一个char变量,所以49就会被以ASCII解码,就是1.
>
> 那为什么我们不直接scanf处理c呢,因为**scanf用了%d转换说明就只能处理int不能处理char;
>
> 再来一个好玩的:如果我们if语句的判断条件写的是49 == '1',那么这个if照样执行.

- 混合输入

> ```c
> scanf("%d %c",&i,&c);
> scanf("%d%c",&i,&c);
> ```
>
> 用第一行代码,如果我们输入	12 a 得到正确的结果,输入	12 1,也是正确的结果.
>
> 但如果我们用第二行代码,我们再输入12 a,发现这时候c不是a了,c是 (空格);
>
> 所以说这时候我们就知道,对于整数转换说明,空格开头的输入编译器会自动跳过,但是对于字符转换说明,空格就不是一个可忽略的东西了.

- 字符计算

> 字符既然在计算机里头是ASCII码,也就是数字,那么它当然可以进行计算.
>
> 比方说我们把'A'赋给c,然后c++,输出c,我们显然得到'B';

#### 逃逸字符

> \b	回退一格
>
> \ "	双引号
>
> \t	到下一个表格位
>
> \n	换行
>
> \r	回车
>
> \ '	单引号
>
> \ \	反斜杠本身

### 字符串

#### 字符串基础

```c
char word[] = {'H','e','l','l','o'};
char word[] = {'H','e','l','l','o','\0'};

```

> 上面两行代码,都是定义字符数组,那哪个是字符串呢?
>
> 显然是第二个.

- C语言中,字符串值得是以0结尾的一串字符.

> - 0和'\0'是一样的,但是和'0'不同
> - 0标志着字符串的结束,但并不是字符串的一部分
> - 计算字符串长度的时候不包含这个0
> - 字符串以数组的形式存在,以数组或指针的形式访问(更多是指针)
> - string.h中有很多处理字符串的函数

- 定义字符串

> ```c
> char *str = "hello";
> char word[] = "hello";
> char line[10] = "hello";
> ```
>
> - "hello"	叫字符串常量,它会被编译器变成一个字符数组,存放在某处,而且长度是6,因为结尾必须要有零.
> - 两个相邻的字符串常量会被自动连接,比如"hello""你好"就会被识别为"hello你好".

- 字符串的C特性

> - 以字符数组形式存在
> - 不能用运算符对字符串做运算
> - 通过数组的方式可以遍历字符串
> - 可以用字符串字面量来初始化字符串数组

#### 字符串变量

- 指针定义字符串的只读特性

> 如果我们定义了*c 然后赋给它一个字符串常量,我们再定义 *d 赋给它同样的字符串常量,这时候我们输出c,d看看这两个里面存放的地址是什么,我们会发现,两个地址一模一样.而且还很小.
>
> 同时,我们如果想要把字符串修改一下,比如 *c[0] = 'A'; 我们编译运行,代码居然报错了,为什么?
>
> - 答案是这个字符串常量就没有放在和本地变量一样的地方,我们本地变量存放了c,d然后c,d指向了这个字符串,这个字符串存放再"代码区",而且,它是只读的.
>
> 所以,我们尝试修改的话,程序就会报错.
>
> - 实际上这个c是const char *c,只是由于历史原因,编译器不支持这样写.

- 如何定义一个可以修改的字符串

> 我们用数组定义. char c[] = "hello world";

- 如何选择?

> 数组:作为本地变量空间自动回收,但可修改
>
> 指针:处理参数,但无法修改,动态分配空间,可作函数参数. 
>
> **如果要去构造字符串,用数组**
>
> **如果要去处理字符串,用指针**

#### 字符串输入输出

- 转换说明%s

> char string[8];
>
> scanf("%s",string); scanf读入一个单词,到空格/tab/回车为止.(不读空格)
>
> - 但scanf是不安全的,因为不知道要读入的内容的长度.
> - 安全方式:在把%s变成%7s,告诉scanf我只要读7个东西.

- 常见错误

> - char *string 误以为char * 就是字符串类型,定义了一个字符串类型的变量string就直接用了,这种错误最要命的就是它具有随机性,可能你的电脑能跑,别的电脑就跑不了了.
>
> - 空字符串: char buffer[100] = "";这样写是空的字符串,buffer[0] == '\0';
>
>   但如果这样写:char buffer[] = "";妄图像之前一样让计算机自动识别数组的长度,对不起,计算机会告诉你这个数组长度只有1!因为里面已经输入过一个'\0'了/

#### 字符串函数

- strlen

> size_t strlen(const char *s);
>
> 返回s的字符串长度(不包括结尾的0)
>
> 用法如下:
>
> ```c
> strlen(line);
> ```

- strcmp

>int strcmp(const char *s1,const char *s2);
>
>
>
>比较两个字符串,返回
>
>0 :s1 == s2
>
>s1和s2的ASCII差值 :s1 >s2
>
>s1和s2的ASCII差值 :s1<s2

- strcpy

> char *strcpy(char *restrict dst,const char *restrict src);
>
> - 把src的字符拷贝到dst中(安全问题:空间不足)
>
> - restrict表明src和dst不重叠
>
> - 返回dst
>
> - 为了能链起代码

- strcat

> char *strcat(char *restrict s1,const char *restrict s2);
>
> - 把s2拷贝到s1的后面,接成一个长的字符串(安全问题:空间不足)
> - 返回s1
> - s1必须具有足够的空间

上述非安全函数都有安全版本,不再赘述.





​										==**完结撒花**==





